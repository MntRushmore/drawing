<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>HandPaint ‚Äî draw with your hands</title>
  <style>
    :root{ --bg:#0f0f14; --muted:#1b1b24; --text:#f5f7ff; --accent:#a0e9ff; --accent2:#ffb3c1; --good:#3ddc97; --warn:#ffd166; --panel:rgba(20,20,30,.6); }
    *{box-sizing:border-box} html,body{height:100%}
    body{ margin:0; background: radial-gradient(1200px 800px at 15% 20%, #1b1b24 0%, #0f0f14 60%), url('data:image/svg+xml;utf8,<svg xmlns=%22http://www.w3.org/2000/svg%22 width=%2270%22 height=%2770%22><circle cx=%2235%22 cy=%2235%22 r=%221%22 fill=%22%232a2a39%22/></svg>'); color:var(--text); font:16px/1.5 ui-rounded, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; overflow:hidden; -webkit-tap-highlight-color:transparent }
    #app{position:relative; width:100vw; height:100vh}
    canvas{position:absolute; inset:0; width:100%; height:100%}
    #overlay{pointer-events:none}
    #ui{position:fixed; left:1rem; top:1rem; right:1rem; display:flex; gap:.6rem; flex-wrap:wrap; align-items:center; z-index:10; backdrop-filter: blur(10px); background:var(--panel); border:1px solid #2c2c3a; padding:.55rem .75rem; border-radius:16px; box-shadow:0 10px 40px rgba(0,0,0,.3)}
    .btn, .seg input+label{display:inline-flex; align-items:center; gap:.5rem; padding:.45rem .65rem; border-radius:12px; border:1px solid #2a2a36; background:#16161f; color:var(--text); cursor:pointer; user-select:none}
    .seg{display:inline-flex; background:#12121a; padding:.25rem; border-radius:12px; border:1px solid #2a2a36}
    .seg input{display:none}
    .swatch{width:22px; height:22px; border-radius:50%}
    #rightDock{position:fixed; right:1rem; top:5.2rem; width:320px; display:flex; flex-direction:column; gap:.6rem; z-index:9}
    .card{background:var(--panel); border:1px solid #2c2c3a; border-radius:16px; padding:.85rem; box-shadow:0 10px 40px rgba(0,0,0,.35)}
    .row{display:flex; align-items:center; justify-content:space-between; gap:.75rem; margin:.35rem 0}
    .row input[type=range]{width:160px}
    #status{position:fixed; left:1rem; bottom:1rem; display:flex; gap:.6rem; align-items:center; background:var(--panel); border:1px solid #2c2c3a; border-radius:12px; padding:.5rem .7rem; box-shadow:0 10px 30px rgba(0,0,0,.3)}
    #video{position:fixed; right:1rem; bottom:1rem; width:180px; height:128px; object-fit:cover; border-radius:12px; border:1px solid #2c2c3a; opacity:.36}
    #tip{position:fixed; inset:auto auto 7.5rem 1rem; max-width:420px; background:var(--panel); border:1px solid #2c2c3a; border-radius:14px; padding:.7rem .8rem; box-shadow:0 10px 30px rgba(0,0,0,.35)}
  </style>
</head>
<body>
  <div id="app">
    <canvas id="paint"></canvas>
    <canvas id="overlay"></canvas>
    <video id="video" playsinline muted></video>
  </div>

  <div id="ui">
    <button id="startBtn" class="btn">üé• Start Camera</button>
    <div class="seg" id="modeSeg"><input type="radio" id="mode-draw" name="mode" value="draw" checked><label class="btn" for="mode-draw">‚úçÔ∏è Draw</label><input type="radio" id="mode-erase" name="mode" value="erase"><label class="btn" for="mode-erase">üßΩ Erase</label></div>
    <div class="seg" id="styleSeg"><input type="radio" id="style-ink" name="style" value="ink" checked><label class="btn" for="style-ink">üñãÔ∏è Ink</label><input type="radio" id="style-neon" name="style" value="neon"><label class="btn" for="style-neon">üåà Neon</label><input type="radio" id="style-water" name="style" value="water"><label class="btn" for="style-water">üíß Watercolor</label><input type="radio" id="style-spray" name="style" value="spray"><label class="btn" for="style-spray">‚ú® Particles</label></div>
    <div class="seg" id="mirrorSeg"><input type="checkbox" id="mirrorX" checked><label class="btn" for="mirrorX">‚ÜîÔ∏è Mirror X</label><input type="checkbox" id="mirrorY"><label class="btn" for="mirrorY">‚ÜïÔ∏è Mirror Y</label><input type="checkbox" id="symm"><label class="btn" for="symm">‚ùáÔ∏è Kaleido</label></div>
    <button id="undoBtn" class="btn">‚Ü©Ô∏è Undo</button>
    <button id="recBtn" class="btn">‚è∫Ô∏è Record</button>
    <button id="timelapseBtn" class="btn">‚è±Ô∏è Timelapse</button>
    <button id="saveBtn" class="btn">üíæ Save PNG</button>
    <button id="clearBtn" class="btn">üßπ Clear</button>
  </div>

  <div id="rightDock">
    <div class="card">
      <div class="row"><span>Brush size</span><input type="range" id="size" min="2" max="48" value="12"></div>
      <div class="row"><span>Flow</span><input type="range" id="flow" min="0.05" max="1" step="0.05" value="0.9"></div>
      <div class="row"><span>Color (H)</span><input type="range" id="hue" min="0" max="360" value="190"></div>
      <div class="row"><span>Background</span>
        <select id="bgSelect">
          <option value="dark">Dark</option>
          <option value="paper">Paper</option>
          <option value="grid">Grid</option>
          <option value="upload">Upload...</option>
        </select>
        <input type="file" id="bgUpload" accept="image/*" style="display:none" />
      </div>
      <div class="row"><label><input type="checkbox" id="glow"> Glow</label><label><input type="checkbox" id="multiHand"> Multi-hand</label></div>
      <div class="hint">Gestures: pinch toggles draw ‚Ä¢ open palm stops ‚Ä¢ U=undo ‚Ä¢ S=save ‚Ä¢ R=record</div>
    </div>
  </div>

  <div id="status"><span id="statText">Ready</span> ¬∑ <span id="fps">0 fps</span></div>
  <div id="tip">Tip: Try <b>Neon</b> + <b>Kaleido</b> and record a timelapse!</div>

  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

  <script>
  const $ = s => document.querySelector(s);
  const lerp = (a,b,t)=>a+(b-a)*t;
  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const dpr = Math.min(1.5, window.devicePixelRatio || 1);

  const video = $('#video');
  const paint = $('#paint');
  const overlay = $('#overlay');
  const pctx = paint.getContext('2d');
  const octx = overlay.getContext('2d');

  let W=0,H=0; let drawing=false; let lastPts=[null,null]; let hue=190; let brushSize=12; let flow=0.9; let mode='draw'; let style='ink';
  let history=[]; const MAX_UNDO=12;

  function resize(){ W = paint.width = overlay.width = Math.floor(innerWidth * dpr); H = paint.height = overlay.height = Math.floor(innerHeight * dpr); paint.style.width = overlay.style.width = innerWidth+'px'; paint.style.height= overlay.style.height= innerHeight+'px'; pctx.lineCap='round'; pctx.lineJoin='round'; octx.setTransform(1,0,0,1,0,0); }
  addEventListener('resize', resize); resize();

  function setStatus(t){ $('#statText').textContent = t; }
  function pushUndo(){ try{ history.push(paint.toDataURL()); if(history.length>MAX_UNDO) history.shift(); }catch(e){} }
  function undo(){ const url=history.pop(); if(!url) return; const img=new Image(); img.onload=()=>{ pctx.clearRect(0,0,W,H); pctx.drawImage(img,0,0,W,H); }; img.src=url; }

  // UI
  $('#startBtn').onclick = async ()=>{ try{ await startCamera(); setStatus('Camera started'); $('#startBtn').disabled=true; $('#startBtn').textContent='‚úÖ Camera on'; $('#tip').remove(); }catch(e){ setStatus('Camera error: '+e.message); }};
  $('#saveBtn').onclick = ()=>{ const a=document.createElement('a'); a.download='handpaint-'+Date.now()+'.png'; a.href=paint.toDataURL('image/png'); a.click(); };
  $('#clearBtn').onclick = ()=>{ pushUndo(); pctx.clearRect(0,0,W,H); };
  $('#undoBtn').onclick = undo;
  $('#size').oninput = e=> brushSize = +e.target.value;
  $('#flow').oninput = e=> flow = +e.target.value;
  $('#hue').oninput = e=> hue = +e.target.value;
  document.querySelectorAll('#styleSeg input').forEach(r=> r.onchange=()=> style=r.value);
  document.querySelectorAll('#modeSeg input').forEach(r=> r.onchange=()=> mode=r.value);

  // background chooser
  $('#bgSelect').onchange = (e)=>{ const v=e.target.value; if(v==='paper'){ document.body.style.background = 'radial-gradient(1200px 800px at 15% 20%, #f7f5ef 0%, #efe9dd 60%)'; } else if(v==='grid'){ document.body.style.background = "repeating-linear-gradient(90deg,#0f0f14 0 1px, transparent 1px 40px), radial-gradient(1200px 800px at 15% 20%, #1b1b24 0%, #0f0f14 60%)"; } else if(v==='upload'){ $('#bgUpload').click(); } else { location.reload(); }};
  $('#bgUpload').onchange = (ev)=>{ const f=ev.target.files[0]; if(!f) return; const url=URL.createObjectURL(f); document.body.style.background = `url(${url}) center/cover fixed, radial-gradient(1200px 800px at 15% 20%, rgba(0,0,0,0.25), rgba(0,0,0,0.55))`; };

  // Recording (normal) using MediaRecorder from canvas stream
  let recorder=null, recordedBlobs=[];
  $('#recBtn').onclick = ()=>{ if(recorder && recorder.state==='recording'){ recorder.stop(); $('#recBtn').textContent='‚è∫Ô∏è Record'; setStatus('Recording stopped'); } else startRecording(); };

  function startRecording(){ recordedBlobs=[]; const stream = paint.captureStream(30); try{ recorder = new MediaRecorder(stream, { mimeType: 'video/webm;codecs=vp9' }); }catch(e){ recorder = new MediaRecorder(stream); }
    recorder.ondataavailable = e=>{ if(e.data && e.data.size>0) recordedBlobs.push(e.data); };
    recorder.onstop = ()=>{ const blob = new Blob(recordedBlobs, {type:'video/webm'}); const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download='handpaint_recording.webm'; a.click(); URL.revokeObjectURL(url); };
    recorder.start(); $('#recBtn').textContent='‚è∫Ô∏è Stop'; setStatus('Recording...'); }

  // Timelapse: sample frames, then render into offscreen canvas at target fps while recording
  let timelapseSampling=false; let tlFrames=[]; let tlIntervalId=null;
  $('#timelapseBtn').onclick = ()=>{ if(timelapseSampling) stopTimelapse(); else startTimelapse(); };
  function startTimelapse(){ tlFrames=[]; timelapseSampling=true; const sampleMs = 200; setStatus('Timelapse: sampling every '+sampleMs+'ms'); tlIntervalId = setInterval(async ()=>{ try{ const bitmap = await createImageBitmap(paint); tlFrames.push(bitmap); }catch(e){} }, 200); $('#timelapseBtn').textContent='‚è±Ô∏è Stop'; }
  async function stopTimelapse(){ timelapseSampling=false; clearInterval(tlIntervalId); $('#timelapseBtn').textContent='‚è±Ô∏è Timelapse'; setStatus('Compiling timelapse...'); if(tlFrames.length===0){ setStatus('No frames captured'); return; }
    // play frames to offscreen canvas and record at 30fps
    const off = new OffscreenCanvas(W, H); const offCtx = off.getContext('2d'); const stream = off.captureStream(30); let rec; try{ rec = new MediaRecorder(stream, {mimeType:'video/webm;codecs=vp9'}); }catch(e){ rec = new MediaRecorder(stream); }
    const chunks=[]; rec.ondataavailable=e=>{ if(e.data && e.data.size) chunks.push(e.data); };
    rec.start(); const targetFps=30; const delay = Math.max(1, Math.floor(1000/targetFps)); // ms per frame
    for(let i=0;i<tlFrames.length;i++){ offCtx.clearRect(0,0,W,H); offCtx.drawImage(tlFrames[i],0,0,W,H); // await one tick
      await new Promise(r=>setTimeout(r, delay)); }
    // give recorder a moment
    await new Promise(r=>setTimeout(r, 200)); rec.stop(); rec.onstop = ()=>{ const blob = new Blob(chunks,{type:'video/webm'}); const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download='handpaint_timelapse.webm'; a.click(); URL.revokeObjectURL(url); setStatus('Timelapse ready'); tlFrames.forEach(b=>b.close && b.close()); tlFrames=[]; };
  }

  // Mediapipe setup + smoothing per hand
  let hands, camera; let lastTime=performance.now();
  class SmoothPt{ constructor(){ this.x=null; this.y=null; } update(nx,ny){ if(this.x==null){ this.x=nx; this.y=ny; return {x:nx,y:ny}; } const dx=nx-this.x, dy=ny-this.y; const speed=Math.hypot(dx,dy)+1e-6; const k=clamp(1-(speed*0.5),0.12,0.8); this.x+= (nx-this.x)*(0.35*k); this.y+= (ny-this.y)*(0.35*k); return {x:this.x,y:this.y}; } reset(){ this.x=this.y=null; } }
  const smoothers = [new SmoothPt(), new SmoothPt()];

  async function startCamera(){ hands = new Hands({locateFile: f=>`https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`}); hands.setOptions({ maxNumHands:2, modelComplexity:1, minDetectionConfidence:0.7, minTrackingConfidence:0.7 }); hands.onResults(onResults);
    const stream = await navigator.mediaDevices.getUserMedia({video:{width:{ideal:1280},height:{ideal:720},facingMode:'user'}, audio:false}); video.srcObject=stream; await video.play(); camera = new Camera(video, { onFrame: async ()=>{ await hands.send({image:video}); }, width:1280, height:720 }); camera.start(); }

  let lost=0; let pinchStates=[false,false];
  function onResults(results){ const now=performance.now(); $('#fps').textContent = Math.round(1000/(now-lastTime))+' fps'; lastTime=now; octx.clearRect(0,0,W,H);
    if(!results.multiHandLandmarks || results.multiHandLandmarks.length===0){ lost++; if(lost>3){ setStatus('Show your hand'); smoothers.forEach(s=>s.reset()); lastPts=[null,null]; } return; } lost=0;
    // multi-hand support
    const handsCount = results.multiHandLandmarks.length;
    for(let hi=0; hi<handsCount; hi++){
      const lm = results.multiHandLandmarks[hi];
      const tipN = lm[8]; const thumbN = lm[4]; const wristN = lm[0]; const midN = lm[9];
      const handScale = Math.hypot(midN.x-wristN.x, midN.y-wristN.y)+1e-6; const pinchOn = 0.55*handScale; const pinchOff = 0.75*handScale; const pinchDist = Math.hypot(tipN.x-thumbN.x, tipN.y-thumbN.y);
      if(!pinchStates[hi] && pinchDist<pinchOn){ pinchStates[hi]=true; drawing = !drawing; setStatus(drawing? 'Drawing: ON':'Drawing: OFF'); pushUndo(); }
      if(pinchStates[hi] && pinchDist>pinchOff){ pinchStates[hi]=false; }
      const pix = {x:tipN.x*W, y:tipN.y*H}; const spt = smoothers[hi].update(pix.x,pix.y);
      // draw guide
      octx.save(); octx.globalAlpha=0.9; octx.strokeStyle = drawing? (hi===0? '#a0e9ff' : '#ffb3c1') : '#3a3a55'; octx.lineWidth=2; octx.beginPath(); octx.arc(spt.x,spt.y,12,0,Math.PI*2); octx.stroke(); octx.restore();
      // draw if active
      if(!drawing){ lastPts[hi]=null; continue; }
      const curr = spt; if(!lastPts[hi]){ lastPts[hi]=curr; continue; }
      // draw per-hand
      const handColor = (results.multiHandedness && results.multiHandedness[hi] && results.multiHandedness[hi].label==='Left') ? `hsl(${(hue+40)%360},100%,75%)` : `hsl(${hue},100%,70%)`;
      drawBrushMulti(lastPts[hi], curr, handColor);
      lastPts[hi]=curr;
    }
  }

  function drawBrushMulti(from, to, handColor){ const useX=$('#mirrorX').checked, useY=$('#mirrorY').checked, useK=$('#symm').checked; const arr=[from]; if(useX) arr.push({x:W-from.x,y:from.y}); if(useY) arr.push({x:from.x,y:H-from.y}); if(useX&&useY) arr.push({x:W-from.x,y:H-from.y}); if(useK){ const cx=W/2, cy=H/2, dx=from.x-cx, dy=from.y-cy; arr.push({x:cx+dy,y:cy+dx},{x:cx-dy,y:cy-dx}); }
    const arrB=[to]; if(useX) arrB.push({x:W-to.x,y:to.y}); if(useY) arrB.push({x:to.x,y:H-to.y}); if(useX&&useY) arrB.push({x:W-to.x,y:H-to.y}); if(useK){ const cx=W/2, cy=H/2, dx=to.x-cx, dy=to.y-cy; arrB.push({x:cx+dy,y:cy+dx},{x:cx-dy,y:cy-dx}); }
    for(let i=0;i<arr.length;i++){ const a=arr[i], b=arrB[i]; if(style==='spray'){ const steps=Math.max(1,Math.floor(Math.hypot(a.x-b.x,a.y-b.y)/8)); for(let s=0;s<=steps;s++){ const t=s/steps; const x=lerp(a.x,b.x,t), y=lerp(a.y,b.y,t); for(let k=0;k<6;k++){ const r=Math.random()*brushSize, ang=Math.random()*Math.PI*2, px=x+Math.cos(ang)*r, py=y+Math.sin(ang)*r; pctx.globalAlpha = 0.08*flow; pctx.fillStyle = handColor; pctx.beginPath(); pctx.arc(px,py,Math.max(1,brushSize*0.15*Math.random()),0,Math.PI*2); pctx.fill(); } } } else { pctx.save(); if(style==='neon'){ pctx.shadowColor = handColor; pctx.shadowBlur = brushSize*1.6; } pctx.globalAlpha = flow; pctx.strokeStyle = handColor; pctx.lineWidth = brushSize; pctx.beginPath(); pctx.moveTo(a.x,a.y); pctx.lineTo(b.x,b.y); pctx.stroke(); if(style==='water'){ pctx.gl
